<!DOCTYPE html>
<html>
<head>
<title>Java_Laborator_5_2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}



div.ticks > ul {
    padding: 0 !important;
}

div.ticks ul {
    list-style-type: none !important;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #962440; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

div.ticks > ul {
    padding: 0;
}

div.ticks ul {
    list-style-type: none;
}
</style>
<link rel="stylesheet" href="file:///d%3A/github-markdown.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
  
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>
<h1 id="tehnici-avansate-de-programare-java-laborator-nr5">Tehnici avansate de programare (Java), Laborator nr.5</h1>
<p>Тема: <strong>Общение между потоками</strong>.</p>
<p>Выполнил: <strong>Curmanschii Anton</strong>, IA1901.</p>
<p><a href="https://github.com/AntonC9018/uni_java/tree/master/lab5_2">Ссылка на код на гитхабе.</a></p>
<h2 id="%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0">Задача</h2>
<p>Дана матрица размерностью $N \times N$. Эта матрица модифициуется на протяжении нескольких итераций по правилу, что к каждой клетке добавляется величина, равная сумме ее соседей. Необходимо параллелизовать процесс итераций, распределив работу на количество тредов, данное, например, с консоли от юзера.</p>
<p>Важно: треды должны считать и вписывать значения во второй буфер (или во временный), который в конце итерации будет сменяться с текущим. Если этого не сделать, получится, что треды переписывают данные в текущей матрице, что некорректно повлияет на вычисления.</p>
<h1 id="%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Реализация</h1>
<p>Сделал 2 варианта: первый централизовано управляет потоками и итерациями, запуская на каждой итерации новое множество потоков; второй вариант использует общение между тредами через монитор для синхронизации их работы.</p>
<h2 id="%D0%BF%D0%B5%D1%80%D0%B2%D1%8B%D0%B9-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80">Первый вариант: централизованный координатор</h2>
<p>Определил класс Grid, который будет хранить в себе буфер под матрицу. Добавил двойную буферизацию, то есть определил поле под еще один буфер той же размерности, что и первый, в который будут вписывать результаты вычисений треды. Можно было бы использовать и плоские массивы вместо двумерных. Это в целом не сильно бы повлияло на итоговый код.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grid</span>
</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] primaryBuffer;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] secondaryBuffer;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Grid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dimension)</span>
    </span>{
        primaryBuffer   = createBuffer(dimension);
        secondaryBuffer = createBuffer(dimension);
    }
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapBuffers</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">int</span>[][] t = primaryBuffer;
        primaryBuffer = secondaryBuffer;
        secondaryBuffer = t;
    }
</div></code></pre>
<p>Сделал пару методов для суммирования и сохранения данных. Решил не делать вариант с заполнением границ нулями, поскольку проверка вышла всего одна, и она довольно понятна.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span>
</span>{
    <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; primaryBuffer.length 
        &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; primaryBuffer[<span class="hljs-number">0</span>].length)
    {
        <span class="hljs-keyword">return</span> primaryBuffer[row][col];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span>
</span>{
    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>; i &lt;= row + <span class="hljs-number">1</span>; i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col - <span class="hljs-number">1</span>; j &lt;= col + <span class="hljs-number">1</span>; j++)
            sum += at(i, j);
    }
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeSumAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span>
</span>{
    secondaryBuffer[row][col] = sumAt(row, col);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeSumAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flatIndex)</span>
</span>{
    storeSumAt(flatIndex / dimension(), flatIndex % dimension());
}
</div></code></pre>
<p>Создал класс, имплементирующий <code>Runnable</code>, который будет вызывать функции суммирования на <code>Grid</code>. Это тонкая прослойка, которая просто имеет в себе начальную позицию, число элементов, доставшееся треду для обработки, и ссылку на <code>Grid</code>-родитель.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> 
</span>{
    <span class="hljs-keyword">private</span> Grid parent;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> start;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> share;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadContext</span><span class="hljs-params">(Grid parent, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> share)</span>
    </span>{
        <span class="hljs-keyword">this</span>.parent = parent;
        <span class="hljs-keyword">this</span>.start = start;
        <span class="hljs-keyword">this</span>.share = share;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> 
    </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; share; i++)
        {
            parent.storeSumAt(start + i);
        }
    }
}
</div></code></pre>
<p>Функция для выполнения итераций подсчета делится на 2 фазы: инициализация контекстов тредов с раздачей начальных позиций и длины и выполнение заданного числа циклов.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performParallelIterations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numThreads, <span class="hljs-keyword">int</span> numIters)</span>
</span>{
    ThreadContext[] contexts = <span class="hljs-keyword">new</span> ThreadContext[numThreads];
    <span class="hljs-keyword">int</span> numElements = dimension() * dimension();
    <span class="hljs-keyword">double</span> sharePerThread = (<span class="hljs-keyword">double</span>)numElements / numThreads;
    <span class="hljs-keyword">double</span> currentStart = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads - <span class="hljs-number">1</span>; i++)
    {
        <span class="hljs-keyword">double</span> nextStart = Math.ceil(sharePerThread * (i + <span class="hljs-number">1</span>));
        <span class="hljs-keyword">int</span> start = (<span class="hljs-keyword">int</span>)(currentStart);
        <span class="hljs-keyword">int</span> share = (<span class="hljs-keyword">int</span>)(nextStart - currentStart);
        currentStart = nextStart;
        contexts[i] = <span class="hljs-keyword">new</span> ThreadContext(<span class="hljs-keyword">this</span>, start, share);
    }
    
    <span class="hljs-comment">// account for possible floating point errors</span>
    {
        <span class="hljs-keyword">int</span> lastStart = (<span class="hljs-keyword">int</span>)currentStart;
        <span class="hljs-keyword">int</span> lastShare = (<span class="hljs-keyword">int</span>)numElements - lastStart;
        contexts[numThreads - <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> ThreadContext(<span class="hljs-keyword">this</span>, lastStart, lastShare);
    }
        
    Thread threads[] = <span class="hljs-keyword">new</span> Thread[numThreads];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numIters; i++)
    {
        <span class="hljs-comment">// create and run the threads</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numThreads; j++)
        {
            threads[j] = <span class="hljs-keyword">new</span> Thread(contexts[j]);
            threads[j].start();
        }
        
        <span class="hljs-comment">// wait for their completion</span>
        <span class="hljs-keyword">for</span> (Thread t : threads)
        {
            <span class="hljs-keyword">try</span> 
            {
                t.join();
            } 
            <span class="hljs-keyword">catch</span> (InterruptedException e) 
            {
                e.printStackTrace();
            }
        }

        swapBuffers();
    }
}
</div></code></pre>
<p>В мейне вызовим функцию для первого варианта, в которой создадим и инициализируем матрицу, а также выполним пару итераций.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>
</span>{
    test1();
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span>
</span>{
    Grid grid = <span class="hljs-keyword">new</span> Grid(<span class="hljs-number">1000</span>);
    grid.randomize();
    grid.printResult();
    System.out.println(<span class="hljs-string">"--------------------------------------------------"</span>);
    grid.performParallelIterations(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);
    grid.printResult();
}
</div></code></pre>
<p>Принт показывает лишь левую верхнюю секцию таблицы (10 на 10).</p>
<pre class="hljs"><code><div>   1    1    0    1   -1    1    0    0   -1    1
   0    1   -1    1    1    0    1    0   -1   -1
   1    1   -1    1   -1    0    1   -1   -1   -1
   0   -1    0    0    1    0   -1   -1    0    0
   0   -1    0   -1    0    1   -1    0    0   -1
  -1    0    0    1   -1    1   -1    0   -1    1
  -1    1    1    0    1   -1    1    0    1   -1
  -1   -1   -1   -1    0    0    1    0    1    1
   0    0    0   -1   -1    0    1   -1    1    0
   0    1    0   -1   -1   -1   -1   -1   -1    1
--------------------------------------------------
  71   99  104   89   93   68   18  -64 -126 -141
  92  125  131  115  124   83   -4 -134 -227 -237
  46   59   72   80   97   46  -61 -195 -275 -262
 -15  -25   -5   25   46   -5 -104 -209 -253 -217
 -67  -89  -52   -1   24  -19  -91 -154 -163 -125
 -81 -104  -66  -16   11    2  -22  -38  -36  -14
 -90 -126 -109  -72  -39   -1   28   59   69   75
 -86 -143 -175 -176 -150  -69    9   82  102  105
 -87 -167 -245 -288 -280 -187  -77   26   70   73
 -80 -160 -253 -320 -335 -251 -126   -7   52   46
</div></code></pre>
<h2 id="%D0%B2%D1%82%D0%BE%D1%80%D0%BE%D0%B9-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D1%82%D1%80%D0%B5%D0%B4%D1%8B-%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B8%D1%80%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D1%81%D0%B0%D0%BC%D0%B8">Второй вариант: треды координируются сами</h2>
<p>Для выполнения этого варианта, будем локально создавать общий временный объект, который будет служить монитором, счетчиком для оставшегося количества итераций, а также счетчиком общего и текущего количества тредов. Будем передовать контекстам треда этот общий объект, который они будут использовать для координации.</p>
<p>В основной функции подсчета в гриде не будем проводить итераций: просто создадим наши контексты тредов, сами треды и их запустим.</p>
<p>Когда один из тредов закончит свои подсчеты в текущей итерации, он синхронно увеличит число завершивших работу тредов в объекте-координаторе, а потом уснет до тех пор, пока все треды не завершат работу. Если тред был последним завершившим работу, он, вместо того, чтобы уснуть, разбудит всех спящих. Повторяем, пока остаточное число циклов не обнулится.</p>
<p>Для начала создадим класс объекта-координатора. Решил сделать этот объект просто вспомогательной структурой с данными, с которой будут работать треды.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coordinator</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalThreadCount;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> itersLeft;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> runningThreadCount;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Coordinator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalThreadCount, <span class="hljs-keyword">int</span> itersLeft)</span> 
    </span>{
        <span class="hljs-keyword">this</span>.totalThreadCount = totalThreadCount;
        <span class="hljs-keyword">this</span>.itersLeft = itersLeft;
        <span class="hljs-keyword">this</span>.runningThreadCount = totalThreadCount;
    }
}
</div></code></pre>
<p>В конструктор контекста добавим этого координатора, а также обновим его основной метод, как описано выше.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadContext2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> 
</span>{
    <span class="hljs-keyword">private</span> Coordinator coordinator;
    <span class="hljs-keyword">private</span> Grid2 parent;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> start;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> share;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadContext2</span><span class="hljs-params">(Coordinator coordinator, Grid2 parent, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> share)</span>
    </span>{
        <span class="hljs-keyword">this</span>.coordinator = coordinator;
        <span class="hljs-keyword">this</span>.parent = parent;
        <span class="hljs-keyword">this</span>.start = start;
        <span class="hljs-keyword">this</span>.share = share;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> 
    </span>{
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; share; i++)
            {
                parent.storeSumAt(start + i);
            }

            <span class="hljs-keyword">synchronized</span> (coordinator)
            {
                coordinator.runningThreadCount--;

                <span class="hljs-keyword">if</span> (coordinator.runningThreadCount == <span class="hljs-number">0</span>)
                {
                    parent.swapBuffers();
                }
                
                <span class="hljs-keyword">if</span> (coordinator.itersLeft &gt; <span class="hljs-number">1</span>)
                {
                    <span class="hljs-keyword">if</span> (coordinator.runningThreadCount == <span class="hljs-number">0</span>)
                    {
                        <span class="hljs-keyword">if</span> (coordinator.runningThreadCount == <span class="hljs-number">0</span>)
                        {
                            coordinator.itersLeft--;
                            coordinator.runningThreadCount = coordinator.totalThreadCount;
                            coordinator.notifyAll();
                        }
                    }
                    <span class="hljs-keyword">else</span> 
                    {
                        <span class="hljs-keyword">try</span>
                        {
                            coordinator.wait();
                        }
                        <span class="hljs-keyword">catch</span> (InterruptedException e) 
                        {
                            e.printStackTrace();
                        }
                    } 
                }
                <span class="hljs-keyword">else</span>
                {
                    <span class="hljs-keyword">return</span>;
                }
            }
        }
    }
}
</div></code></pre>
<p>В методе суммирования в гриде убираем цикл и корректно инициализируем координатора (показывать не буду, так как там все просто, смотрите файлы лабы).</p>
<p>Результаты схожие:</p>
<pre class="hljs"><code><div>   1    1   -1    0    0   -1    0    1    1   -1
   1    1   -1    0    0    1    0   -1    0    1
   0    0    0   -1   -1    1   -1   -1   -1   -1
  -1   -1    1    1    0    1   -1    0    0    0
  -1    0    0   -1   -1    1   -1    1   -1    0
  -1    1    1    0    1   -1    0   -1    1    0
   1   -1    1    1    0    0    1    0    0    1
  -1    0    1    1    0    0    1    1    0   -1
   0    0    1    0    1    0   -1   -1   -1    0
   0   -1    0    1    1   -1   -1    0    1    1
--------------------------------------------------
  46   39    0  -37  -35  -32  -32  -44  -55  -72
  46   30  -18  -63  -56  -62  -75 -114 -140 -175
   6  -10  -26  -45  -37  -68 -105 -171 -204 -248
 -32  -41  -23  -18  -18  -64 -106 -175 -211 -268
 -29   -8   44   65   43  -14  -54  -99 -127 -180
   3   57  125  149  107   49   11  -16  -49 -102
  30  115  206  242  184  111   55   32   -3  -44
  26  117  222  271  207  112   34    4  -22  -53
  -4   71  180  235  169   56  -23  -37  -24  -34
 -37    5   95  140   84  -23  -74  -63   -8   -6
</div></code></pre>
<h2 id="%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-1">Обновление 1</h2>
<p>Можем печатать промежуточный результат. Для этого, изменим код в ифе последнего треда:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (coordinator.runningThreadCount == <span class="hljs-number">0</span>)
{
    parent.printResult();
    System.out.println(<span class="hljs-string">"--------------------------------------------------"</span>);

    parent.swapBuffers();

    <span class="hljs-keyword">if</span> (coordinator.itersLeft == <span class="hljs-number">1</span>)
    {
        parent.printResult();
    }
}
</div></code></pre>
<p>А в мейне, не будем печатать буфер:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>
</span>{
    Grid2 grid = <span class="hljs-keyword">new</span> Grid2(<span class="hljs-number">1000</span>);
    grid.randomize();
    grid.performParallelIterations(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);
}
</div></code></pre>
<p>Результат:</p>
<pre class="hljs"><code><div>  -1    1   -1    0   -1   -1    0   -1   -1    0 
   0    1   -1    1   -1    1    0   -1    1    1 
  -1    1   -1    0   -1    1    0    0   -1   -1 
   0    1    1    1    1   -1    1   -1   -1    1 
   1    1    1    1    1    1    0    0   -1   -1 
   0   -1    0   -1   -1   -1   -1    1    0    0 
   1    1    0    0   -1   -1    1   -1   -1   -1 
   0    0   -1    1   -1    1    0    0    1   -1 
   1    1   -1    0    0    0    0    1   -1    1 
  -1   -1    1    0    0    1   -1    1   -1    1 
--------------------------------------------------
   1   -1    1   -3   -1   -2   -2   -2   -1    0 
   1   -2    1   -5   -1   -2   -1   -3   -3   -3 
   2    1    4    0    2    1    0   -2   -2    0 
   3    4    6    4    4    3    1   -3   -5   -3 
   2    4    4    4    1    0   -1   -2   -2    0 
   3    4    2    0   -2   -2   -1   -2   -4   -3 
   1    0   -1   -4   -4   -4   -1    0   -2   -2 
   4    2    1   -3   -1   -1    1    0   -2   -1 
   0   -1    0   -1    2    0    3    0    2    0 
  -2   -1   -1    0    1    2    5    1    2    0 
--------------------------------------------------
  -1    1   -9   -8  -14   -9  -12  -12  -12   -8 
   2    8   -4   -2  -11   -6  -13  -16  -16   -7 
   9   20   13   15    6    7   -6  -18  -24  -12 
  16   30   31   29   19   11   -3  -16  -19   -5 
  20   32   32   23   12    3   -7  -19  -24  -15 
  14   19   13    0  -11  -14  -13  -15  -17  -17 
  14   16    1  -12  -21  -15  -10  -11  -16  -20 
   6    6   -7  -11  -16   -5   -2    1   -5   -8 
   2    2   -4   -2   -1   12   11   12    2    4 
 -13  -18  -13   -4    5   19   18   20    9   11 
--------------------------------------------------
  10   -3  -14  -48  -50  -65  -68  -81  -71  -48 
  39   39   34  -14  -22  -58  -85 -129 -125  -81 
  85  125  140   96   68    4  -60 -131 -133  -69 
 127  203  225  180  125   42  -48 -136 -152  -83 
 131  207  209  148   72   -3  -73 -133 -147  -91 
 115  161  124   37  -35  -76 -101 -132 -154 -125 
  75   82   25  -64 -105 -107  -84  -88 -108 -109 
  46   36  -11  -73  -71  -47   -7  -18  -41  -60 
 -15  -39  -51  -53   -3   41   86   66   46   10 
 -75 -115 -106  -56   31  102  147  121   97   63 
</div></code></pre>
<h2 id="%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D1%8B">Выводы</h2>
<p>Если бы дали задание зарефакторить этот код, разделил бы почетче сообщения между классами (кто кем владеет и к кому обращается), потому что в текущем коде все обращаются друг к другу и не особо понятно кто главный.</p>
<p>Если хорошенько подумать, то и объект координатора тут не нужен, поскольку можно было бы хранить все необходимые данные в классе грида и использовать его в качестве монитора.</p>
<p>Еще нашел в интернете, что существуют вспомогательные классы для работы с потоками в неймспейсе <code>java.util.concurrent</code>, и что рекомендуют использовать их, дабы не переизобретать велосипед.</p>

</body>
</html>
