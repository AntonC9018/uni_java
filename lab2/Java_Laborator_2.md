# Tehnici avansate de programare (Java), Laborator nr.2

Выполнил: **Curmanschii Anton**, IA1901.

## Задания (Вариант 9)

1.	Описать иерархию классов (минимум 4). Базовый класс абстрактный с минимум 1 абстрактной функцией
2.	Описать class Main с функцией main вне иерархии
3.	Описать как минимум 2 интерфейса, каждый подключить минимум в 1 класс иерархии
4.	Каждый наследный класс должен иметь уникальные поля и методы
5.	Вызвать конструкторы классов родителей с параметрами и без 
6.	Вызвать обычные функции из классов родителей 
7.	Переопределить в каждом классе Randomize в дефолтном конструкторе
8.	Переопределить в каждом классе функцию ввода полей с клавиатуры
9.	Переопределить в каждом классе функцию записи в файл 						
10.	Создать минимум одну final : переменную && функцию && класс
11.	Создать минимум одну static : переменную && функцию
12.	Использовать instanceof и преобразование типов объектов 
13.	В main создать вектора объектов с типами: базовый класс && интерфейс 
14.	В функции main для созданных объектов вызвать уникальные функции их классов, вывести их на экран
15.	Описать в отчете собственный вариант работы так, как показано в примерах ниже.

## Планировка

Решил сделать иерархию по примеру видеоигры. Скажем, возьмем следующие типы: `Entity` -> `Creature` -> `Humanoid` -> `Orc` -> `Orc Warrior`.

> Ремарка: иерархия классов, как правило, не используется в видеоиграх, потому что она слишком жесткая ( и не только). В видеоиграх обычно используются более гибкие компоненты, которые модифицируют `Entity`.

`Entity` обычно включает `entity_id` и список компонетов. Для лабы, оставим только айди.

`Creature`, скажем, будет включать позицию в мире (вектор из 2 компонентов), массу и значение атаки. Добавим метод проверки, если `Creature` находится на одной позиции с другим `Creature`. Еще добавим поле `health` и свойство `isAlive()`. Добавим виртуальныу методы `attack()` и `beAttacked()`. Добавим метод `move()` для смены позиции. Также добавим геттеры для массы и значения атаки.

`Humanoid` будет содержать по 2 объекта рук. Добавим также поле `armor`, которое будет содержать надетую броню. Заоверрайдим геттер значения атаки и метод `beAttacked()`, чтобы они учитывали броню и конечности. Заоверрайдим свойство массы, чтобы оно учитывало массу брони.

`Orc` добавляет характеристику `rage`. Заоверрайдим метод геттер значения атаки, чтобы он учитывал эту характеристику. Добавим  свойство `isEnraged()` и метод `enrage()`, который увеличивает `rage`.

`OrcWarrior` добавляет метод `dash()`, который одновременно перемещает его, и атакует цель.

Класс `Hand` наследуют `Entity` и содержит свойство `isMetallic()`.

Класс `Armor` наследует `Entity` и добавляет массу и броню.

Для сериализации используем встроенный в Java функционал. 

Как интерфейсы возьмем `IAttackable` с методом `beAttacked()`, `IAttacking` с методом `attack()`, `IMoving` с методом `move()`, и `IDashing`, который комбинирует `IMoving` и `IAttacking`, а также добавляет метод `dash()`. Также определим `IWithMass` с геттером для массы.
